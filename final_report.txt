MAIN PROMPT:
==============
In addition, a final report must be written for the project. This should be between 2 to 5 full pages in length (double-spaced, 12pt font, 1" margins). The report should include a full description of the problem(s) being solved, your motivation for solving the problem(s), how the problem(s) was broken down into classes, how those classes interacted to solve the problem(s), and what you learned by doing this project.

ESSAY:
========
My final project proposal was to build a Tetris clone from the ground up using nothing but raw c++.  This was an ambitious endeavor, but I didn't realize just how ambitious it actually was. However, I've seen this game so often and love playing the old retro versions of it that were nice and simple. I'm no good at them, but its a fun game nonetheless. The original versions had none of the fanciness that more modern clones of Tetris, so I figured that if I kept the scope small and stuck to implementing the core of the game that I could actually do it. I used a 29 year old external library to make this happen, which is interesting, called NCurses. It's basically a library that allows you to make "GUI" programs that run in the terminal, these are called "TUI" programs. Now, immediately after I got approval for this I knew there were a couple big systems that I would have to figure out how to implement. These included collision, rotation, line clearing, and some of the more mundane things like actually displaying the game.

For collision I almost immediately had the idea to use parallel two dimensional char arrays for board state management. One of which would contain the pieces that are currently dynamic, meaning they are moving. The other of which would contain the pieces that have already collided with something and are static. Now what about the OOP? I made an abstract class that described what a piece actually was, I called it Tetrimino. This class is in charge of holding the data that all tetriminos require like a position, size, and a shape. The different types of Tetriminos rotate and collide in different ways, so using just a single Tetrimino class wouldn't work. We need a seperate class for them, that derive from the base Tetrimino. The reason is that each type of piece can implement its own unique way of rotation and/or collision. Also by having each more specific tetrimino type inherit from the base tetrimino class I was able to do maintain a simle Tetrimino pointer as the active piece. Active meaning it is the piece currently being queried for rotations, movement, and collision. As soon as this piece collides we no longer need it so it gets replaced by a random new instance! This is an example of reusing a single member variable for almost the entire game, but having it also be able to change! Without pointers this approach is simple not possible.

The two board arrays are really the core of the program, as the tetrimino class and its children have lots of methods in them that take them in as arguments and directly operate on their memory. The tetrimino classes are sort of managers of the main game state, but do so using instance member variables. It's sort of an interesting approach to OOP that I never really expected to use, but it really was the simplest and most effective way to do it. If I were to maintain a simple list/array of tetriminos almost everything seems more complicated. As I would have to do collision checks by looping over every single tetrimino in the game, and given the complexity of how they need to interact this would get big and cumbersome really fast. But by maintaining these arrays I was able to centralize everything.
